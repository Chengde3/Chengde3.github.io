---
layout: post
title: 从1到n整数中1出现的次数
date: 2015-08-30
categories: Algorithm
tags: algorithm
---

## 1. 问题描述

输入一个整数n，求从1到n这n个整数中十进制表示中1出现的次数。

## 2. 解题思路

思路一：

- 每次通过对10求余数判断整数的个位数字是不是1；
- 输入数字n，n有O(logn)位，故时间复杂度为O(n\*logn)；

思路二：

有如下规律：

- 0-9，之间1的个数为1；
- 00-99，从两个位置中选一个位置置为1，其余每一位有10种选择，故有：2\*10 = 20;(只考虑十位是否有1，共有10种，仅考虑个位是否有1，共有10种)
- 000-999，从三个位置中选一个位置置为1，其余每一位有10种选择，故有：3\*10\*10 = 300;
- 0000-9999，从三个位置中选一个位置置为1，其余每一位有10种选择，故有：4*10*10*10 = 4000;
- 因此可以将n一次划分即可；
- 例如21345可以如下计算，(10000 + 2\*4\*1000) + (345+1 + 1\*300) + (100 + 3\*20) + (10 + 4\*1) + (1 + 0);
- (10^4 + 2\*4\*10^(4-1)) + (345+1 + 1\*300) + (10^2 + 3\*2\*10^(2-1)) + (10^1 + 4\*1\*10^(1-1)) + (1 + 0)

思路三：

有如下规律：

- 0-9，之间1的个数为1；
- 00-99，个位数有10个0-9，故有10\*1=10次，而十位为1的有10次，故有10\*1 + 10 = 20；
- 000-999，十位个位共有10个00-99，故有10\*20=200次，而百位为1的有100次，故有200+100=300次；
- 0000-9999，百位十位个位共有10个000-999，故有10\*300=3000次，而千位为1的有1000次，共有3000+1000=4000次；

## 3. 参考代码

//思路一参考代码
{% highlight c++ %}
int NumberOf1(unsigned int n);
int NumberOf1Between1AndN(unsigned int n) {
	int number = 0;
	for(unsigned int i = 1; i <= n; i++)
		number += NumberOf1(i);
	return number;
}

int NumberOf1(unsigned int n) {
	int number = 0;
	while(n) {
		if(n % 10 == 1)
			number++;
		n = n / 10;
	}

	return number;
}
{% endhighlight c++ %}

//思路二参考代码
{% highlight c++ %}
#include<stdio.h>

long long PowerBase10(long long n) {
	long long result = 1;
	for(int i = 0; i < n; i++)
		result *= 10;

	return result;
}

long long NumberOf1(long long n) {

	long long tmp = n;
	long long count = 0;
	long long weight = 1;
	long long digit = 0;

	int x;		//数的当前位
	//数的当前基数，从零开始计；
	int curDigit = 0;

	while(tmp) {
		x = tmp % 10;
		if(curDigit == 0) {
			weight = 0;
		} else {
			weight = x * curDigit * PowerBase10(curDigit-1);
		}

		if(x == 1) {	
			digit = n % PowerBase10(curDigit) + 1;
		} else {
			digit = PowerBase10(curDigit);
		}

		count += (digit + weight);

		curDigit += 1;
		tmp /= 10;
	}
	return count;
}

int main() {
	long long input = 21345;
	printf("%lld\n", NumberOf1(input));
	return 0;
}
{% endhighlight c++ %}

//剑指offer上面的代码；
{% highlight c++ %}
int NumberOf1(const char* strN);
int PowerBase10(unsigned int n);
int NumberOf1Between1AndN(int n) {
	if(n <= 0)
		return 0;
	char strN[50];
	//将格式化的数据写入字符串
	sprintf(strN, "%d", n);

	return NumberOf1(strN);
}

int NumberOf1(const char* strN) {
	if(!strN || *strN < '0' || *strN > '9' || *strN == '\0')
		return 0;

	//字符转整数
	int first = *strN - '0';
	unsigned int length = static_cast<unsigned int>(strlen(strN));

	if(length == 1 && first == 0)
		return 0;
	if(length == 1 && first > 0)
		return 1;

	//假设strN是21345，numFirstDigit是数字10000-19999的第一位中的数目
	int numFirstDigit = 0;
	if(first > 1) 
		numFirstDigit = PowerBase10(length - 1);
	else if(first == 1) 
		numFirstDigit = atoi(strN + 1) + 1;

	//numOtherDigits是1346-21345除了第一位之外的数位中的数目
	int numOtherDigits = first * (length-1) * PowerBase10(length-2);
	//numRecursive是1-1345中的数目
	int numRecursive = NumberOf1(strN + 1);

	return numFirstDigit + numOtherDigits + numRecursive;
}

int PowerBase10(unsigned int n) {
	int result = 1;
	for(unsigned int i = 0; i < n; i++) {
		result *= 10;
	}
	return result;
}
{% endhighlight c++ %}

//思路三代码
{% highlight c++ %}
long long NumberOf1(long long n) {
	long long count = 0;

	//0			:0
	//0~9		:1		= 10*0 + 1;
	//00-99		:20		= 10*1 + 10
	//000-999	:300	= 10*20 + 100;
	//0000-9999	:4000	= 10*300 + 1000
	long long a = 0;			//0,1,20,300,4000
	long long weight = 1;		//1,10,100,1000
	//数的当前位
	int x;

	long long temp = n;
	while(temp) {
		x = temp % 10;

		count += x*a;

		//加上当前位1的个数
		//若该位>1，则当前位为1的个数为10^(m-1)
		if(x > 1) 
			count += weight;
		else if(x == 1) {
			//若该位=1，则当前位为1的个数应该为该数右边的数字组成的数+1
			count += n % weight + 1;
		}

		a = 10 * a + weight;	//an = 10 * a(n-1) + 10 ^ (m-1), m为位数
		weight *= 10;

		temp /= 10;
	}
	return count;
}
{% endhighlight c++ %}

## 4. 思考

- 剑指offer上面给的解释有误；
- 通过例子找出一般规律，此方面有待加强，希望多动手；

## 5. 参考

- [程序员面试题精选100题(25)-在从1到n的正数中1出现的次数[算法]](http://zhedahht.blog.163.com/blog/static/25411174200732494452636/)(剑指offer的博客)
- [google面试题及我的算法（2）——0~n之间1的个数（完美版）](http://blog.csdn.net/livelylittlefish/article/details/2768348)(思路三参考博客)
- [编程之美系列之三——计算1的个数](http://www.cnblogs.com/jy02414216/archive/2011/03/09/1977724.html)
- [《剑指offer》](http://www.broadview.com.cn/#book/bookdetail/bookDetailAll.jsp?book_id=12c9bc27-a944-11e4-9c0a-005056c00008&isbn=978-7-121-23245-9)